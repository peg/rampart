// Copyright 2026 The Rampart Authors
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package openclaw provides integration helpers for OpenClaw.
//
// The sync command reads Rampart policies and generates equivalent
// OpenClaw configuration (tools.deny, exec-approvals) so operators
// can maintain a single policy source of truth.
package openclaw

import (
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"github.com/peg/rampart/internal/engine"
)

// SyncResult holds the generated OpenClaw configuration.
type SyncResult struct {
	// ToolsDeny is the list of tool names to deny entirely.
	ToolsDeny []string `json:"tools_deny,omitempty"`

	// ExecDenyPatterns are command patterns that should be blocked.
	ExecDenyPatterns []string `json:"exec_deny_patterns,omitempty"`

	// ExecAllowPatterns are command patterns explicitly allowed (for paranoid mode).
	ExecAllowPatterns []string `json:"exec_allow_patterns,omitempty"`

	// ReadDenyPaths are file path patterns that should be blocked for reads.
	ReadDenyPaths []string `json:"read_deny_paths,omitempty"`

	// WriteDenyPaths are file path patterns that should be blocked for writes.
	WriteDenyPaths []string `json:"write_deny_paths,omitempty"`

	// Profile is the source Rampart profile name.
	Profile string `json:"profile"`

	// GeneratedAt is when this config was generated.
	GeneratedAt time.Time `json:"generated_at"`

	// SourceFile is the Rampart policy file used.
	SourceFile string `json:"source_file"`
}

// SyncFromConfig reads a Rampart engine.Config and extracts OpenClaw-compatible settings.
func SyncFromConfig(cfg *engine.Config, sourceFile string) *SyncResult {
	result := &SyncResult{
		GeneratedAt: time.Now().UTC(),
		SourceFile:  sourceFile,
	}

	if cfg.DefaultAction == "deny" {
		result.Profile = "paranoid"
	} else {
		result.Profile = "standard"
	}

	for _, policy := range cfg.Policies {
		if !policy.IsEnabled() {
			continue
		}

		tools := []string(policy.Match.Tool)

		for _, rule := range policy.Rules {
			action, err := rule.ParseAction()
			if err != nil {
				continue
			}

			switch action {
			case engine.ActionDeny:
				extractDenyRules(result, tools, rule)
			case engine.ActionAllow:
				extractAllowRules(result, tools, rule)
			}
		}
	}

	return result
}

func extractDenyRules(result *SyncResult, tools []string, rule engine.Rule) {
	for _, tool := range tools {
		switch strings.ToLower(tool) {
		case "exec":
			result.ExecDenyPatterns = append(result.ExecDenyPatterns, rule.When.CommandMatches...)
		case "read":
			result.ReadDenyPaths = append(result.ReadDenyPaths, rule.When.PathMatches...)
		case "write":
			result.WriteDenyPaths = append(result.WriteDenyPaths, rule.When.PathMatches...)
		}
	}
}

func extractAllowRules(result *SyncResult, tools []string, rule engine.Rule) {
	for _, tool := range tools {
		switch strings.ToLower(tool) {
		case "exec":
			result.ExecAllowPatterns = append(result.ExecAllowPatterns, rule.When.CommandMatches...)
		}
	}
}

// FormatOpenClawConfig generates a human-readable OpenClaw config snippet.
func FormatOpenClawConfig(result *SyncResult) string {
	var b strings.Builder

	fmt.Fprintf(&b, "// Generated by: rampart openclaw sync\n")
	fmt.Fprintf(&b, "// Source: %s (%s profile)\n", result.SourceFile, result.Profile)
	fmt.Fprintf(&b, "// Generated: %s\n", result.GeneratedAt.Format(time.RFC3339))
	fmt.Fprintf(&b, "//\n")
	fmt.Fprintf(&b, "// Merge these settings into your ~/.openclaw/openclaw.json5\n\n")

	b.WriteString("{\n")

	if len(result.ExecDenyPatterns) > 0 || len(result.ReadDenyPaths) > 0 {
		b.WriteString("  // Rampart policy enforcement via OpenClaw native controls\n")
		b.WriteString("  tools: {\n")

		if len(result.ToolsDeny) > 0 {
			b.WriteString("    deny: [")
			for i, t := range result.ToolsDeny {
				if i > 0 {
					b.WriteString(", ")
				}
				fmt.Fprintf(&b, "%q", t)
			}
			b.WriteString("],\n")
		}

		b.WriteString("  },\n")
	}

	b.WriteString("}\n")

	if len(result.ExecDenyPatterns) > 0 || len(result.ExecAllowPatterns) > 0 {
		b.WriteString("\n// --- exec-approvals.json additions ---\n")
		b.WriteString("// Add these patterns to ~/.openclaw/exec-approvals.json\n\n")

		approvals := buildExecApprovals(result)
		data, _ := json.MarshalIndent(approvals, "", "  ")
		b.Write(data)
		b.WriteString("\n")
	}

	return b.String()
}

func buildExecApprovals(result *SyncResult) map[string]any {
	agent := map[string]any{}

	// Paranoid mode: deny-by-default with explicit allowlist.
	// Standard mode: allow-by-default, use "on-miss" to prompt for unknowns.
	if result.Profile == "paranoid" {
		agent["security"] = "allowlist"
		agent["ask"] = "on-miss"
		agent["askFallback"] = "deny"

		if len(result.ExecAllowPatterns) > 0 {
			allowlist := make([]map[string]string, 0, len(result.ExecAllowPatterns))
			for _, pattern := range result.ExecAllowPatterns {
				allowlist = append(allowlist, map[string]string{
					"pattern": pattern,
				})
			}
			agent["allowlist"] = allowlist
		}
	} else {
		// Standard mode: allowlist + ask for anything not recognized.
		agent["security"] = "allowlist"
		agent["ask"] = "on-miss"
		agent["askFallback"] = "deny"

		if len(result.ExecDenyPatterns) > 0 {
			agent["_blocked_patterns_comment"] = "These patterns are blocked by Rampart. " +
				"OpenClaw exec-approvals uses allowlists, so these serve as documentation. " +
				"Rampart enforces the actual denial."
			agent["_blocked_patterns"] = result.ExecDenyPatterns
		}
	}

	defaults := map[string]any{
		"security":    "allowlist",
		"ask":         "on-miss",
		"askFallback": "deny",
	}

	return map[string]any{
		"version":  1,
		"defaults": defaults,
		"agents": map[string]any{
			"main": agent,
		},
		"_generated_by": fmt.Sprintf("rampart openclaw sync from %s", result.SourceFile),
	}
}
