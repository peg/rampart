// Copyright 2026 The Rampart Authors
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package proxy

import (
	"fmt"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"time"

	"github.com/peg/rampart/internal/engine"
	"gopkg.in/yaml.v3"
)

// autoAllowedRule is a single rule returned by the rules API.
type autoAllowedRule struct {
	Index          int    `json:"index"`
	Tool           string `json:"tool"`
	CommandPattern string `json:"command_pattern"`
	PathPattern    string `json:"path_pattern,omitempty"`
	Name           string `json:"name"`
	Created        string `json:"created,omitempty"`
}

func (s *Server) handleGetAutoAllowed(w http.ResponseWriter, r *http.Request) {
	if !s.checkAuth(w, r) {
		return
	}

	policyPath := engine.DefaultAutoAllowedPath()
	data, err := os.ReadFile(policyPath)
	if err != nil {
		if os.IsNotExist(err) {
			writeJSON(w, http.StatusOK, map[string]any{"rules": []any{}})
			return
		}
		writeError(w, http.StatusInternalServerError, fmt.Sprintf("failed to read auto-allowed rules: %v", err))
		return
	}

	var cfg engine.Config
	if err := yaml.Unmarshal(data, &cfg); err != nil {
		writeError(w, http.StatusInternalServerError, fmt.Sprintf("failed to parse auto-allowed rules: %v", err))
		return
	}

	rules := make([]autoAllowedRule, 0, len(cfg.Policies))
	for i, p := range cfg.Policies {
		rule := autoAllowedRule{
			Index: i,
			Name:  p.Name,
		}

		if len(p.Match.Tool) > 0 {
			rule.Tool = p.Match.Tool[0]
		}

		// Extract command/path pattern from the first rule's conditions.
		if len(p.Rules) > 0 {
			r := p.Rules[0]
			if len(r.When.CommandMatches) > 0 {
				rule.CommandPattern = r.When.CommandMatches[0]
			}
			if len(r.When.PathMatches) > 0 {
				rule.PathPattern = r.When.PathMatches[0]
			}
		}

		// Try to extract timestamp from policy name (format: ...-YYYYMMDDTHHMMSSZ).
		if len(p.Name) > 16 {
			suffix := p.Name[len(p.Name)-16:]
			if t, err := time.Parse("20060102T150405Z", suffix); err == nil {
				rule.Created = t.Format(time.RFC3339)
			}
		}

		rules = append(rules, rule)
	}

	writeJSON(w, http.StatusOK, map[string]any{"rules": rules})
}

func (s *Server) handleDeleteAutoAllowed(w http.ResponseWriter, r *http.Request) {
	if !s.checkAuth(w, r) {
		return
	}

	indexStr := r.PathValue("index")
	index, err := strconv.Atoi(indexStr)
	if err != nil {
		writeError(w, http.StatusBadRequest, "invalid index")
		return
	}

	policyPath := engine.DefaultAutoAllowedPath()
	data, err := os.ReadFile(policyPath)
	if err != nil {
		if os.IsNotExist(err) {
			writeError(w, http.StatusNotFound, "no auto-allowed rules file")
			return
		}
		writeError(w, http.StatusInternalServerError, fmt.Sprintf("failed to read: %v", err))
		return
	}

	var cfg engine.Config
	if err := yaml.Unmarshal(data, &cfg); err != nil {
		writeError(w, http.StatusInternalServerError, fmt.Sprintf("failed to parse: %v", err))
		return
	}

	if index < 0 || index >= len(cfg.Policies) {
		writeError(w, http.StatusNotFound, "rule index out of range")
		return
	}

	// Remove the rule at index.
	cfg.Policies = append(cfg.Policies[:index], cfg.Policies[index+1:]...)

	// If no rules left, delete the file.
	if len(cfg.Policies) == 0 {
		if err := os.Remove(policyPath); err != nil && !os.IsNotExist(err) {
			writeError(w, http.StatusInternalServerError, fmt.Sprintf("failed to remove file: %v", err))
			return
		}
		// Force immediate engine reload so the revoked rule stops applying right away.
		if s.engine != nil {
			if reloadErr := s.engine.Reload(); reloadErr != nil {
				s.logger.Error("proxy: post-change reload failed", "error", reloadErr)
				writeError(w, http.StatusInternalServerError, fmt.Sprintf("policy removed but reload failed: %v", reloadErr))
				return
			}
		}
		writeJSON(w, http.StatusOK, map[string]any{"deleted": true})
		return
	}

	// Write back atomically.
	out, err := yaml.Marshal(&cfg)
	if err != nil {
		writeError(w, http.StatusInternalServerError, fmt.Sprintf("failed to marshal: %v", err))
		return
	}

	header := fmt.Sprintf("# Auto-generated by Rampart â€” do not edit manually.\n# Last updated: %s\n",
		time.Now().UTC().Format(time.RFC3339))

	dir := filepath.Dir(policyPath)
	tmpFile, err := os.CreateTemp(dir, ".rampart-policy-*.yaml.tmp")
	if err != nil {
		writeError(w, http.StatusInternalServerError, fmt.Sprintf("failed to create temp file: %v", err))
		return
	}
	tmpPath := tmpFile.Name()

	if _, err := tmpFile.WriteString(header + string(out)); err != nil {
		tmpFile.Close()
		os.Remove(tmpPath)
		writeError(w, http.StatusInternalServerError, fmt.Sprintf("failed to write: %v", err))
		return
	}
	if err := tmpFile.Close(); err != nil {
		os.Remove(tmpPath)
		writeError(w, http.StatusInternalServerError, fmt.Sprintf("failed to close: %v", err))
		return
	}
	if err := os.Rename(tmpPath, policyPath); err != nil {
		os.Remove(tmpPath)
		writeError(w, http.StatusInternalServerError, fmt.Sprintf("failed to rename: %v", err))
		return
	}

	// Force immediate engine reload so the revoked rule stops applying right away.
	if s.engine != nil {
		if reloadErr := s.engine.Reload(); reloadErr != nil {
			s.logger.Error("proxy: post-change reload failed", "error", reloadErr)
			writeError(w, http.StatusInternalServerError, fmt.Sprintf("policy written but reload failed: %v", reloadErr))
			return
		}
	}

	writeJSON(w, http.StatusOK, map[string]any{"deleted": true})
}
